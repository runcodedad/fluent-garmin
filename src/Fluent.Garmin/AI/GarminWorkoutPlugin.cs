using System.ComponentModel;
using System.Text.Json;
using Microsoft.SemanticKernel;

namespace Fluent.Garmin.AI;

/// <summary>
/// Semantic Kernel plugin for creating Garmin workouts from AI-generated JSON plans
/// </summary>
public class GarminWorkoutPlugin
{
    /// <summary>
    /// Creates a Garmin workout from a JSON plan generated by an LLM
    /// </summary>
    /// <param name="jsonPlan">JSON string containing the workout plan</param>
    /// <returns>A WorkoutModel that can be used to generate FIT files</returns>
    [KernelFunction("CreateWorkoutFromJson"), Description(@"Creates a Garmin workout from a JSON workout plan. 

JSON Schema:
{
  'name': 'string - workout name',
  'sport': 'enum - Running|Cycling|Swimming|Generic',  
  'steps': [
    {
      'name': 'string - step description',
      'type': 'string - step|warmup|cooldown|repeat',
      'duration': {
        'type': 'enum - Time|Distance|Open|Calories',
        'value': 'number - seconds for Time, meters for Distance, calories for Calories'
      },
      'target': {
        'type': 'enum - Open|HeartRate|Speed|Power|Cadence',
        'zone': 'number 1-5 - predefined training zones',
        'lowValue': 'number - optional custom range low',
        'highValue': 'number - optional custom range high'
      },
      'intensity': 'enum - Active|Rest|Warmup|Cooldown',
      'repeatCount': 'number - for repeat steps only',
      'repeatSteps': 'array - child steps for repeat type'
    }
  ]
}

Example:
{
  'name': 'AI Running Workout',
  'sport': 'Running',
  'steps': [
    {
      'name': 'Warm Up',
      'type': 'warmup', 
      'duration': {'type': 'Time', 'value': 600},
      'target': {'type': 'HeartRate', 'zone': 1},
      'intensity': 'Warmup'
    }
  ]
}")]
    public WorkoutModel CreateWorkoutFromJson(
        [Description("JSON string containing the workout plan following the schema above")] 
        string jsonPlan)
    {
        try
        {
            var workoutPlan = JsonSerializer.Deserialize<WorkoutPlan>(jsonPlan, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                AllowTrailingCommas = true
            });

            if (workoutPlan == null)
                throw new ArgumentException("Invalid JSON workout plan");

            return ConvertToWorkoutModel(workoutPlan);
        }
        catch (JsonException ex)
        {
            throw new ArgumentException($"Failed to parse JSON workout plan: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Creates a Garmin workout file from a JSON plan
    /// </summary>
    /// <param name="jsonPlan">JSON string containing the workout plan</param>
    /// <param name="fileName">Output file name (should end with .fit)</param>
    /// <returns>Path to the created workout file</returns>
    [KernelFunction("CreateWorkoutFile"), Description(@"Creates a Garmin FIT workout file from a JSON workout plan.

Uses the same JSON schema as CreateWorkoutFromJson. The JSON should contain:
- name: workout name
- sport: Running, Cycling, Swimming, or Generic  
- steps: array of workout steps with duration, target, and intensity

Each step should have:
- name: description
- type: step, warmup, cooldown, or repeat
- duration: {type: Time|Distance|Open|Calories, value: number}
- target: {type: Open|HeartRate|Speed|Power|Cadence, zone: 1-5}
- intensity: Active, Rest, Warmup, or Cooldown")]
    public string CreateWorkoutFile(
        [Description("JSON string containing the workout plan following the workout schema")] string jsonPlan,
        [Description("Output filename for the FIT file (should end with .fit)")] string fileName)
    {
        var workoutModel = CreateWorkoutFromJson(jsonPlan);
        
        // Ensure filename has .fit extension
        if (!fileName.EndsWith(".fit", StringComparison.OrdinalIgnoreCase))
        {
            fileName += ".fit";
        }

        WorkoutGenerator.GenerateWorkoutFile(workoutModel, fileName);
        return fileName;
    }

    /// <summary>
    /// Creates Garmin workout file bytes from a JSON plan
    /// </summary>
    /// <param name="jsonPlan">JSON string containing the workout plan</param>
    /// <returns>Byte array containing the .fit workout file data</returns>
    [KernelFunction("CreateWorkoutFileBytes"), Description(@"Creates a Garmin FIT workout file as byte array from a JSON workout plan.

Uses the same JSON schema as CreateWorkoutFromJson. The JSON should contain:
- name: workout name
- sport: Running, Cycling, Swimming, or Generic  
- steps: array of workout steps with duration, target, and intensity

Each step should have:
- name: description
- type: step, warmup, cooldown, or repeat
- duration: {type: Time|Distance|Open|Calories, value: number}
- target: {type: Open|HeartRate|Speed|Power|Cadence, zone: 1-5}
- intensity: Active, Rest, Warmup, or Cooldown

Returns the workout file as bytes so the caller can save it where they choose.")]
    public byte[] CreateWorkoutFileBytes(
        [Description("JSON string containing the workout plan following the workout schema")] string jsonPlan)
    {
        var workoutModel = CreateWorkoutFromJson(jsonPlan);
        return WorkoutGenerator.GenerateWorkoutFileBytes(workoutModel);
    }

    /// <summary>
    /// Validates a JSON workout plan without creating the workout
    /// </summary>
    /// <param name="jsonPlan">JSON string to validate</param>
    /// <returns>Validation result with any error messages</returns>
    [KernelFunction("ValidateWorkoutPlan"), Description(@"Validates a JSON workout plan format against the Garmin workout schema.

Checks that the JSON contains valid:
- name: workout name (string)
- sport: valid sport type (Running, Cycling, Swimming, Generic)
- steps: array of workout steps

For each step validates:
- name: step description
- type: step, warmup, cooldown, or repeat  
- duration: proper type and value
- target: valid target type and zone/range
- intensity: valid intensity level

Returns 'Valid: ...' for good plans or 'Invalid/Warning: ...' with details.")]
    public string ValidateWorkoutPlan(
        [Description("JSON string containing the workout plan to validate against the schema")] string jsonPlan)
    {
        try
        {
            var workoutPlan = JsonSerializer.Deserialize<WorkoutPlan>(jsonPlan, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                AllowTrailingCommas = true
            });

            if (workoutPlan == null)
                return "Invalid: JSON plan is null";

            if (string.IsNullOrWhiteSpace(workoutPlan.Name))
                return "Warning: Workout name is empty";

            if (workoutPlan.Steps.Count == 0)
                return "Warning: Workout has no steps";

            // Basic validation of steps
            for (int i = 0; i < workoutPlan.Steps.Count; i++)
            {
                var step = workoutPlan.Steps[i];
                
                if (string.IsNullOrWhiteSpace(step.Name))
                    return $"Warning: Step {i + 1} has no name";

                if (step.Duration.Value == 0 && step.Duration.Type != DurationType.Open)
                    return $"Warning: Step {i + 1} ({step.Name}) has zero duration";

                if (step.Type.Equals("repeat", StringComparison.OrdinalIgnoreCase) && step.RepeatSteps.Count == 0)
                    return $"Warning: Repeat step {i + 1} ({step.Name}) has no child steps";
            }

            return "Valid: Workout plan is properly formatted";
        }
        catch (JsonException ex)
        {
            return $"Invalid: JSON parsing error - {ex.Message}";
        }
        catch (Exception ex)
        {
            return $"Invalid: Validation error - {ex.Message}";
        }
    }

    /// <summary>
    /// Converts a WorkoutPlan to a WorkoutModel using the existing builder pattern
    /// </summary>
    private WorkoutModel ConvertToWorkoutModel(WorkoutPlan plan)
    {
        var builder = new WorkoutBuilder()
            .Name(plan.Name)
            .Sport(plan.Sport);

        foreach (var stepPlan in plan.Steps)
        {
            AddStepToBuilder(builder, stepPlan);
        }

        return builder.Build();
    }

    /// <summary>
    /// Adds a step plan to the workout builder
    /// </summary>
    private void AddStepToBuilder(IWorkoutBuilder builder, StepPlan stepPlan)
    {
        var stepType = stepPlan.Type.ToLowerInvariant();

        switch (stepType)
        {
            case "warmup":
                builder.WarmUp(stepPlan.Duration.Minutes, stepPlan.Target.Zone, stepPlan.Target.Type);
                break;

            case "cooldown":
                builder.CoolDown(stepPlan.Duration.Minutes, stepPlan.Target.Zone, stepPlan.Target.Type);
                break;

            case "repeat":
                if (stepPlan.RepeatSteps.Count > 0)
                {
                    var repeatSteps = stepPlan.RepeatSteps.Select(ConvertToWorkoutStep).ToArray();
                    builder.AddRepeat(stepPlan.Name, stepPlan.RepeatCount, repeatSteps);
                }
                break;

            default:
                // Regular step
                builder.AddStep(
                    stepPlan.Name,
                    stepPlan.Duration.Type,
                    stepPlan.Duration.Value,
                    stepPlan.Intensity,
                    stepPlan.Target.Type,
                    stepPlan.Target.Zone
                );
                break;
        }
    }

    /// <summary>
    /// Converts a StepPlan to a WorkoutStep for repeat structures
    /// </summary>
    private WorkoutStep ConvertToWorkoutStep(StepPlan stepPlan)
    {
        var step = new WorkoutStep
        {
            Name = stepPlan.Name,
            Duration = new StepDuration
            {
                Type = stepPlan.Duration.Type,
                Value = stepPlan.Duration.Value
            },
            Intensity = stepPlan.Intensity,
            Target = new StepTarget
            {
                Type = stepPlan.Target.Type,
                Zone = stepPlan.Target.Zone,
                LowValue = stepPlan.Target.LowValue,
                HighValue = stepPlan.Target.HighValue
            }
        };

        return step;
    }
}